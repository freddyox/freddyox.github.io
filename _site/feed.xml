<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.2.1">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2018-06-05T15:19:22-04:00</updated><id>/</id><title type="html">Projects and Research Interests</title><subtitle>Projects and Research Interests</subtitle><entry><title type="html">Tree Fractal II</title><link href="/blog/tree-fractal-v2/" rel="alternate" type="text/html" title="Tree Fractal II" /><published>2018-05-20T00:00:00-04:00</published><updated>2018-05-20T00:00:00-04:00</updated><id>/blog/tree-fractal-v2</id><content type="html" xml:base="/blog/tree-fractal-v2/">&lt;figure&gt;
  &lt;img src=&quot;/images/tree_fractal/tree_road_trip_small.png&quot; alt=&quot;&quot; height=&quot;99%&quot; width=&quot;99%&quot; /&gt;
  &lt;figcaption&gt;Fig. 1 - A fractal tree using my &quot;random tree generator&quot;
  with the black/white option turned ON. The tree has been placed on top of a photograph
  of the Badlands that I took during a road trip (summer of 2012).&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;improvements&quot;&gt;Improvements&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://youtu.be/yIIv5fRgoSY&quot;&gt;The tree fractal program may be seen by this video&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;
&lt;p&gt;I realized that I wanted to play with the fractal tree a bit more… My first
post may be seen &lt;a href=&quot;/blog/tree-fractal/&quot;&gt;here&lt;/a&gt;
which includes an overview of the algorithm. The code has been extended/reformulated
to handle a variety of options in addition to a GUI interface; this is how the tree
gets interesting which I ignored the first time!
While I have written sliders, buttons, and number entries from scratch, I used the C++
&lt;a href=&quot;https://root.cern.ch/root/htmldoc/guides/users-guide/WritingGUI.html&quot;&gt;ROOT GUI widgets&lt;/a&gt;
for this project which has been an absolute pleasure.
Furthermore, instead of simply representing a branch as a line, I included an option to
toggle between lines or user-adjustable trapezoids, where the latter is designed
to give the effect that the diameter of a branch/trunk decreases with height.
The parameters that are now adjustable using GUI widgets are the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; the number of iterations to display &lt;/li&gt;
&lt;li&gt; the number of branches to generate at a particular node (previously I only did 2, but
     now it is possible to choose between [1,10])&lt;/li&gt;
&lt;li&gt; the generation angle which controls the angle of branches in the &lt;i&gt;n+1&lt;/i&gt; iteration
     relative to the &lt;i&gt;n&lt;sup&gt;th&lt;/sup&gt;&lt;/i&gt; iteration &lt;/li&gt;
&lt;li&gt; the length and width of the trunk which affects subsequent branches as well &lt;/li&gt;
&lt;li&gt; the trapezoidal gradient of a branch &lt;/li&gt;
&lt;li&gt; the branch width and length relative to the trunk &lt;/li&gt;
&lt;li&gt; an asymmetry angle offset which yields trees that are biased towards one direction&lt;/li&gt;
&lt;li&gt; an offset for the starting point of a branch &lt;/li&gt;
&lt;li&gt; an option to turn the background back/white which automatically renders the
     tree white/black, respectively &lt;/li&gt;
&lt;li&gt; an option to draw the branches in order/reverse (sometimes branches cover previous
     iterations, therefore this option is for convenience) &lt;/li&gt;
&lt;li&gt; an option to change the tree color palette (15 options) which automatically applies
     a pretty gradient ranging from the trunk to the smallest branch. &lt;/li&gt;
&lt;li&gt; the ability to randomly generate a tree in which the above parameters are tweaked
     according to various probability distributions. &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;
&lt;figure&gt;
  &lt;img src=&quot;/images/tree_fractal/assortment_nsplits_small.png&quot; alt=&quot;&quot; height=&quot;100%&quot; width=&quot;100%&quot; /&gt;
  &lt;figcaption&gt;Fig. 2 - Going clockwise and starting at the top left, the number of branches
  to generate at a new node is 3, 5, 8, and 9. The trunk length and branch ratio relative
  to the trunk have been adjusted to get a
  pretty picture (hence why GUI widgets are wonderful for this project).&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The ability to increase the number of branches at a node significantly changes the
structure of the fractal, &lt;i&gt;e.g.&lt;/i&gt; see Fig. 2 which displays the unexpected
generation of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sierpinski_triangle&quot;&gt;Sierpinski triangle&lt;/a&gt;
among others; this behavior was a huge surprise for me. See Fig. 3 for an example
of a tree with 4 branches generated a every node; it resembles the previous post but
much fuller. Note that the number of branch iterations needs to be monitored when tweaking
the number of branches to generated, otherwise too many lines are drawn and the program
inevitably crashes.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;figure&gt;
  &lt;img src=&quot;/images/tree_fractal/nsplit_4_thickness.png&quot; alt=&quot;&quot; height=&quot;100%&quot; width=&quot;100%&quot; /&gt;
  &lt;figcaption&gt;Fig. 3 - The number of branches generated at each node is 4, and the fractal
  has been generated with a modest angle of approximately 100 degrees.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&quot;random-tree-generator&quot;&gt;Random Tree Generator&lt;/h2&gt;
&lt;p&gt;The random tree generator is useful for creating trees that visually look “natural” in
structure, see Fig. 1. There are a great deal of parameters to randomize; however, this
is what I did:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; change the number of branches to be generated at a particular node 10%
     of the time using a flat random generator - I do not want the change to be large, and
     I adjusted this number by +/- 1 &lt;/li&gt;
&lt;li&gt; 10% of the time, change the length of the branch using a Gaussian distribution
     where the standard deviation is small, specifically 10% of the length of the branches
     that would normally be generated &lt;/li&gt;
&lt;li&gt; 33.3% of the time, change the generation angle with a Gaussian distribution of
     standard deviation equal to 10 degrees&lt;/li&gt;
&lt;li&gt; change the branch starting position with a Gaussian distribution (std dev = 10% of
     the normal branch length, and we must take an absolute value to avoid strange behavior)
     40% of the time &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These parameters can all be changed, obviously, but too many changes yields wild results; therefore,
it is best to control how often a Gaussian (or flat) wiggle occurs. See Fig. 4 and
the figures beyond for examples of the random generator with various options turned ON/OFF.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;figure&gt;
  &lt;img src=&quot;/images/tree_fractal/random_v2.png&quot; alt=&quot;&quot; height=&quot;100%&quot; width=&quot;100%&quot; /&gt;
  &lt;figcaption&gt;Fig. 4 - An example of the random tree generator; note that Fig. 1 also
  is randomly generated, but in black and white (and placed on another image using
  &lt;a href=&quot;https://www.gimp.org/&quot;&gt;GIMP&lt;/a&gt;).
  &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;
&lt;figure&gt;
  &lt;img src=&quot;/images/tree_fractal/more_trees_white.png&quot; alt=&quot;&quot; height=&quot;100%&quot; width=&quot;100%&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;
  &lt;img src=&quot;/images/tree_fractal/random_v6.png&quot; alt=&quot;&quot; height=&quot;100%&quot; width=&quot;100%&quot; /&gt;
  &lt;figcaption&gt;Fig. 5 - The original tree used in Fig. 1.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;/p&gt;</content><summary type="html">A significant upgrade to the previous tree fractal post including a random tree generator</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="" /></entry><entry><title type="html">Fractal Ferns</title><link href="/blog/fractal-fern/" rel="alternate" type="text/html" title="Fractal Ferns" /><published>2018-05-12T00:00:00-04:00</published><updated>2018-05-12T00:00:00-04:00</updated><id>/blog/fractal-fern</id><content type="html" xml:base="/blog/fractal-fern/">&lt;figure&gt;
  &lt;img src=&quot;/images/fern/mod_ferns.png&quot; alt=&quot;&quot; height=&quot;99%&quot; width=&quot;99%&quot; /&gt;
  &lt;figcaption&gt;Fig. 1 - Selected color schemes of a modified Barnsley fern. The
  fern is plotted in a two dimensional histogram, and the color gradient
  depends on the bin content in a log scale.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h1 id=&quot;barnsley-fern&quot;&gt;Barnsley Fern&lt;/h1&gt;
&lt;p&gt;The generation of ferns is surprisingly easy compared to other fractals that I’ve attempted;
however, getting pretty color schemes was not obvious (at least for me).
The fern idea is not mine, but a summary may be seen
&lt;a href=&quot;https://en.wikipedia.org/wiki/Barnsley_fern&quot;&gt;here&lt;/a&gt;. The technique falls
under the category of an &lt;i&gt;iterated function system&lt;/i&gt; which differs
from the generation of a tree fractal or a Koch snowflake. In this
case, very specific matrix transformations are performed on a point, and the type of transformation
is dictated by a flat probability distribution. For example, the canonical fern
is the so-called Barnsley fern, which may be generated by considering some
initial point defined to be &lt;script type=&quot;math/tex&quot;&gt;x_n&lt;/script&gt;. The initial point undergoes linear
transformations of the type &lt;script type=&quot;math/tex&quot;&gt;x_{n+1} \rightarrow Mx_n + b&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is a &lt;script type=&quot;math/tex&quot;&gt;2\times2&lt;/script&gt;
linear transformation and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; is a translational term. The Barnsley fern
is generated by the following choices of &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{align}
\begin{pmatrix} x_{n+1} \\ y_{n+1} \end{pmatrix}
	&amp;= \begin{pmatrix} 0.00 &amp; 0.00 \\ 0.00 &amp; 0.16 \end{pmatrix}
       \begin{pmatrix} x_n \\ y_n   \end{pmatrix} +
       \begin{pmatrix} 0.00 \\ 0.00 \end{pmatrix} \hspace{1cm} P=0.01, \\
\begin{pmatrix} x_{n+1} \\ y_{n+1} \end{pmatrix}
        &amp;= \begin{pmatrix} 0.85 &amp; 0.04 \\ -0.04 &amp; 0.85 \end{pmatrix}
       \begin{pmatrix} x_n \\ y_n   \end{pmatrix} +
       \begin{pmatrix} 0.00 \\ 0.16 \end{pmatrix} \hspace{1cm} P=0.85, \\
\begin{pmatrix} x_{n+1} \\ y_{n+1} \end{pmatrix}
       &amp;= \begin{pmatrix} 0.20 &amp; -0.26 \\ 0.23 &amp; 0.22 \end{pmatrix}
       \begin{pmatrix} x_n \\ y_n   \end{pmatrix} +
       \begin{pmatrix} 0.00 \\ 1.60 \end{pmatrix} \hspace{1cm} P=0.07, \\
\begin{pmatrix} x_{n+1} \\ y_{n+1} \end{pmatrix}
       &amp;= \begin{pmatrix} -0.15 &amp; 0.28 \\ 0.26 &amp; 0.24 \end{pmatrix}
       \begin{pmatrix} x_n \\ y_n   \end{pmatrix} +
       \begin{pmatrix} 0.00 \\ 0.44 \end{pmatrix} \hspace{1cm} P=0.07. \\
\end{align} %]]&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;Which transformation to use depends on a flat random probability distribution
denoted by &lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt;, so for example the first transformation is only applied 1% of
the time while the second is applied 85%. The result is the famous Barnsley fern which
may be seen by Fig. 2; the fern is generated by starting with some initial
point and applying the formula with the defined probabilities many times, say &lt;script type=&quot;math/tex&quot;&gt;10^{5} - 10^{8}&lt;/script&gt;.
This is an &lt;script type=&quot;math/tex&quot;&gt;xy&lt;/script&gt; plot, though, not a histogram which is important when it comes to
assigning colors to the fern. Note that this fern does not look exactly the same as Fig. 1
which are generated using the prescription found
&lt;a href=&quot;http://www.home.aone.net.au/~byzantium/ferns/fractal.html&quot;&gt;here&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{align}
\begin{pmatrix} x_{n+1} \\ y_{n+1} \end{pmatrix}
       &amp;= \begin{pmatrix} 0.00 &amp; 0.00 \\ 0.00 &amp; 0.20 \end{pmatrix}
       \begin{pmatrix} x_n \\ y_n   \end{pmatrix} +
       \begin{pmatrix} 0.00 \\ -0.12 \end{pmatrix} \hspace{1cm} P=0.01, \\
\begin{pmatrix} x_{n+1} \\ y_{n+1} \end{pmatrix}
        &amp;= \begin{pmatrix} 0.845 &amp; 0.035 \\ -0.035 &amp; 0.82 \end{pmatrix}
       \begin{pmatrix} x_n \\ y_n   \end{pmatrix} +
       \begin{pmatrix} 0.00 \\ 1.60 \end{pmatrix} \hspace{1cm} P=0.85, \\
\begin{pmatrix} x_{n+1} \\ y_{n+1} \end{pmatrix}
       &amp;= \begin{pmatrix} 0.20 &amp; -0.31 \\ 0.255 &amp; 0.245 \end{pmatrix}
       \begin{pmatrix} x_n \\ y_n   \end{pmatrix} +
       \begin{pmatrix} 0.00 \\ 0.29 \end{pmatrix} \hspace{1cm} P=0.07, \\
\begin{pmatrix} x_{n+1} \\ y_{n+1} \end{pmatrix}
       &amp;= \begin{pmatrix} -0.15 &amp; 0.24 \\ 0.25 &amp; 0.20 \end{pmatrix}
       \begin{pmatrix} x_n \\ y_n   \end{pmatrix} +
       \begin{pmatrix} 0.00 \\ 0.68 \end{pmatrix} \hspace{1cm} P=0.07, \\
\end{align} %]]&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;which is quite similar to the Barnsley parameters with the exception of the translational terms.
An animation of the fern development is seen by Fig. 4.
The trick to getting the colors observed in Fig. 1 is to plot the fern in a two-dimensional histogram
which contains more information than a simple xy plot. Why? Well, certain points are chosen more
frequently than others, and this information may be captured by a histogram. For example, I used a
large number of bins for the x and y variables, roughly 900 to 1000, and then the
logarithm of the number events in each bin may be used to defined the rgb value.
The ferns in Fig. 1 are displayed in a
log-scale which highlights small differences in bin counts; furthermore, the color gradient observed
in the leaves (there is a proper name for this) occurs naturally.&lt;/p&gt;
&lt;figure&gt;
  &lt;img src=&quot;/images/fern/fern_thumbnail_v3.png&quot; alt=&quot;&quot; height=&quot;60%&quot; width=&quot;60%&quot; /&gt;
  &lt;figcaption&gt;Fig. 2 - The Barnsley fern plotted as an xy scatter plot. Information is lost
  here in regards to color schemes; therefore, I used a two dimensional histogram and a
  log scale as seen in Fig. 1.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;Another pretty fern may be generated using the following values for &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; (found on Wiki)
and may be seen by Fig. 3:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{align}
\begin{pmatrix} x_{n+1} \\ y_{n+1} \end{pmatrix}
       &amp;= \begin{pmatrix} 0.00 &amp; 0.00 \\ 0.00 &amp; 0.25 \end{pmatrix}
       \begin{pmatrix} x_n \\ y_n   \end{pmatrix} +
       \begin{pmatrix} 0.00 \\ -0.40 \end{pmatrix} \hspace{1cm} P=0.02, \\
\begin{pmatrix} x_{n+1} \\ y_{n+1} \end{pmatrix}
        &amp;= \begin{pmatrix} 0.95 &amp; 0.005 \\ -0.005 &amp; 0.93 \end{pmatrix}
       \begin{pmatrix} x_n \\ y_n   \end{pmatrix} +
       \begin{pmatrix} -0.002 \\ 0.50 \end{pmatrix} \hspace{1cm} P=0.84, \\
\begin{pmatrix} x_{n+1} \\ y_{n+1} \end{pmatrix}
       &amp;= \begin{pmatrix} 0.035 &amp; -0.20 \\ 0.16 &amp; 0.04 \end{pmatrix}
       \begin{pmatrix} x_n \\ y_n   \end{pmatrix} +
       \begin{pmatrix} -0.09 \\ 0.02 \end{pmatrix} \hspace{1cm} P=0.07, \\
\begin{pmatrix} x_{n+1} \\ y_{n+1} \end{pmatrix}
       &amp;= \begin{pmatrix} -0.04 &amp; 0.20 \\ 0.16 &amp; 0.04 \end{pmatrix}
       \begin{pmatrix} x_n \\ y_n   \end{pmatrix} +
       \begin{pmatrix} 0.083 \\ 0.12 \end{pmatrix} \hspace{1cm} P=0.07. \\
\end{align} %]]&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;figure&gt;
  &lt;img src=&quot;/images/fern/fern_skinny_2.png&quot; alt=&quot;&quot; height=&quot;100%&quot; width=&quot;100%&quot; /&gt;
  &lt;figcaption&gt;Fig. 3 - Another mutant variation of the Barnsley fern.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;/p&gt;
&lt;figure&gt;
  &lt;img src=&quot;/images/fern/fern.gif&quot; alt=&quot;&quot; height=&quot;50%&quot; width=&quot;50%&quot; /&gt;
  &lt;figcaption&gt;Fig. 4 - An animation of the fern seen in Fig. 1 where the iteration is in
  powers of 10, &lt;i&gt;i.e.&lt;/i&gt; 1 to &lt;i&gt;10&lt;sup&gt;8&lt;/sup&gt;&lt;/i&gt;.&lt;/figcaption&gt;
&lt;/figure&gt;</content><summary type="html">Generating fractal ferns using iterated function systems</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="" /></entry><entry><title type="html">Convex Hulls</title><link href="/blog/convex_hull/" rel="alternate" type="text/html" title="Convex Hulls" /><published>2018-03-20T00:00:00-04:00</published><updated>2018-03-20T00:00:00-04:00</updated><id>/blog/convex_hull</id><content type="html" xml:base="/blog/convex_hull/">&lt;h2 id=&quot;overview-of-algorithm&quot;&gt;Overview of Algorithm&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;image left&quot;&gt;&lt;img src=&quot;/images/convex/convex_for_span.png&quot; alt=&quot;&quot; /&gt;&lt;/span&gt;
The idea is simple: find the minimum number of data points which represent the perimeter convex polygon
about a data set. There are many variations of this algorithm and the applications can
be critical; for example, an introductory machine learning problem is to construct
a boundary (a straight line with 2 weights in the simplest case) between two linearly
separable data sets, where linearly separable means that there exists some line that
perfectly differentiates the two data sets (all the data from one set fall on one side of
the line while all the data from the other set fall on the other side).
However, how does one know if the two data sets are &lt;i&gt;linearly separable&lt;/i&gt;?
One method is to apply the convex hull algorithm to both data sets individually in order
to construct two polygons, then the polygons may be tested for overlaps in order to confirm (or not)
linear separability. Here are the major components of my convex hull algorithm,
which at the core consists of calculating smallest angles between carefully chosen vectors
(See Fig. 1 for an example in which the data are labeled):
&lt;ol&gt;
&lt;li&gt; Generate a data set. I generated points based on a Gaussian distribution with a mean
     and sigma of 0.5 and 0.25, respectively, as I did not want to points to wander too far.&lt;/li&gt;
&lt;li&gt; Each point needs to be indexed using some book-keeping integer for tracking purposes.&lt;/li&gt;
&lt;li&gt; Find the algorithm's starting point - I chose the point with the minimum y value, and
     if there are duplicates then I choose the point with the lowest x and y values, or the
     bottom-left point; this point by definition is part of the hull.
     The starting point in Fig. 1 is labeled as 8.&lt;/li&gt;
&lt;li&gt; Make a hull container which will be used to keep track of the points making
     up the perimeter polygon (or the hull), and insert the starting point as by definition this
     point must be apart of the hull.
     Also, it is useful to make a storage container that contains all
     the data points, which allows for element removal as we traverse the hull;
     this is the container that is used to find points to add to the hull.&lt;/li&gt;
&lt;li&gt; Construct a vector using information from the hull container;
     the first iteration consists of the first hull point 8 and the origin. The
     direction is important as we want to calculate minimum angles. &lt;/li&gt;
&lt;li&gt; Find the minimum angle between a test-case and the hull vector (origin and point 8);
     the test-point with the minimum angle is the next hull point, which
     is labeled by 1 and may now be removed from storage. &lt;/li&gt;
&lt;li&gt; Repeat. The next hull vector is built by points 8 and 1, then the minimum angle
     between this vector and a test-vector is the next hull point;
     in this case, it is given by point 7. Note that this strategy
     allows angles to be calculated by a simple dot product.&lt;/li&gt;
&lt;li&gt; Continue until we reach the starting point, hence the utility of the book-keeping device &lt;/li&gt;     
&lt;/ol&gt;
&lt;/p&gt;
&lt;figure&gt;
  &lt;img src=&quot;/images/convex/example.png&quot; alt=&quot;&quot; height=&quot;99%&quot; width=&quot;99%&quot; /&gt;
  &lt;figcaption&gt;Fig 1. - An example of the algorithm in which the starting point is labeled as 8. Note
  that the numbers are simply a book-keeping device and should not be interpreted as anything more.
  The ordering of the next points are 1, 7, 2, 0, 3, and 8 (return to the starting point),
  which collectively define the hull polygon.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt; &lt;/p&gt;
&lt;figure&gt;
  &lt;img src=&quot;/images/convex/example_of_overlap2.png&quot; alt=&quot;&quot; height=&quot;99%&quot; width=&quot;99%&quot; /&gt;
  &lt;figcaption&gt;Fig 2. - An example of a situation in which the two data sets, differentiated by red squares and black triangles, are not linearly separable.
  The convex hull algorithm may be used to detect this behavior.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&quot;overlapping-convex-polygons&quot;&gt;Overlapping Convex Polygons&lt;/h2&gt;
&lt;p&gt;What if we are interested in the overlapping region between two convex hulls? Assuming
that the hulls overlap, then the boolean AND operation results in another convex polygon.
Determining the overlap can be difficult, but here is what I chose to do:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Break the convex polygon P&lt;sub&gt;1&lt;/sub&gt; of &lt;i&gt;N&lt;/i&gt; vertices into sub-triangles - I wrote a routine
    that takes the hull coordinates (arrays/vectors of x,y points) and returns
    &lt;i&gt;N-2&lt;/i&gt; triangles (in the form of arrays of x,y points). &lt;/li&gt;
&lt;li&gt; Loop through the other hull polygon, denoted by P&lt;sub&gt;2&lt;/sub&gt; which has &lt;i&gt;M&lt;/i&gt; vertices,
     and check to see if any of the x,y points live in the sub-triangles of P&lt;sub&gt;1&lt;/sub&gt;.
     The following function was used for this purpose:
&lt;pre&gt;&lt;code&gt;bool in_triangle(point p, double* x, double* y){
  point p0(x[0],y[0],-1); // triangle vertex
  point p1(x[1],y[1],-1); // triangle vertex
  point p2(x[2],y[2],-1); // triangle vertex
  double A = 0.5 * (-p1.Y() * p2.X() + p0.Y() * (-p1.X() + p2.X())
		    + p0.X() * (p1.Y() - p2.Y()) + p1.X() * p2.Y());
  double sign = A &amp;lt; 0 ? -1 : 1;
  double s = (p0.Y() * p2.X() - p0.X() * p2.Y() + (p2.Y() - p0.Y()) * p.X()
	      + (p0.X() - p2.X()) * p.Y()) * sign;
  double t = (p0.X() * p1.Y() - p0.Y() * p1.X() + (p0.Y() - p1.Y()) * p.X()
	      + (p1.X() - p0.X()) * p.Y()) * sign;

  return s &amp;gt; 0 &amp;amp;&amp;amp; t &amp;gt; 0 &amp;amp;&amp;amp; (s + t) &amp;lt; 2 * A * sign;	
}
&lt;/code&gt;&lt;/pre&gt;
where point p is the point to test in order to determine if it lives
in a triangle of x and y coordinates denoted by p0, p1, and p2; if so, then
the function returns true, otherwise false.&lt;/li&gt;
&lt;li&gt;The inverse needs to be checked, &lt;i&gt;i.e.&lt;/i&gt; check to see if any
points of polygon P&lt;sub&gt;1&lt;/sub&gt; live in P&lt;sub&gt;2&lt;/sub&gt;.&lt;/li&gt;
&lt;li&gt;Intersection points between P&lt;sub&gt;1&lt;/sub&gt; and P&lt;sub&gt;2&lt;/sub&gt; also need
    to be tracked if one desires the overlapping polygon; this can
    be achieved by simple vector intersection.&lt;/li&gt;
&lt;li&gt;All these points need to be tracked and put into an array in CW or CCW order
    in order to build a convex polygon.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The result of the above logic may be seen by Fig. 3. Note that I am only
concerned about the hull polygons, not the data within the hull (which only matter
during the construction of the hull).
The top-left panel displays the two hulls, denoted by H&lt;sub&gt;red&lt;/sub&gt; and H&lt;sub&gt;blk&lt;/sub&gt;.
The top-right panel displays the result of the sub-triangularization method,
and explicitly shows which hull vertices were detected using the above code snippet.
In other words, the red squares are detected in H&lt;sub&gt;blk&lt;/sub&gt; while the black
triangle is a point of the hull H&lt;sub&gt;blk&lt;/sub&gt; that has been detected in H&lt;sub&gt;red&lt;/sub&gt;.
The bottom panel displays the overlapping result in blue, which is another convex polygon.
The markers are coded by shape where the meaning of the square and triangle markers
has just been discussed; the circle markers, however, represent intersection points
between the two convex hulls and must be considered when constructed the overlapping hull.
Note that in the context of linear separability, none of this is necessary; one only needs
to check to see if a point of hull H&lt;sub&gt;blk&lt;/sub&gt; exists within H&lt;sub&gt;red&lt;/sub&gt;
and vice versa.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;figure&gt;
  &lt;img src=&quot;/images/convex/convex_overlap_detection.png&quot; alt=&quot;&quot; height=&quot;99%&quot; width=&quot;99%&quot; /&gt;
  &lt;figcaption&gt;Fig 3 - An overview of the convex hull overlap detection algorithm, which
  is represented by the blue convex polygon.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;/p&gt;</content><summary type="html">An algorithm to find the perimeter of a data set, and includes convex polygon overlap detection</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="" /></entry><entry><title type="html">Word Search</title><link href="/blog/word-search/" rel="alternate" type="text/html" title="Word Search" /><published>2018-01-04T00:00:00-05:00</published><updated>2018-01-04T00:00:00-05:00</updated><id>/blog/word-search</id><content type="html" xml:base="/blog/word-search/">&lt;p&gt;I am not particularly interested in word searches, but for some reason
I found myself making a generator. The word search game is complete and user-interactive,
and the entire project has been coded using the bare-bones tools of SFML which
requires significant &lt;i&gt;behind-the-scenes&lt;/i&gt; routines.
The code is mostly book-keeping tasks, but a decent strategy needs to be developed when it
comes to placing many strings of varying size in a grid.
First, I need a dictionary, or a text file
with hundreds of thousands of words; I chose
&lt;a href=&quot;http://www.math.sjsu.edu/~foster/dictionary.txt&quot;&gt;this one&lt;/a&gt; which explains
why some of the words to find are not commonly accepted words in my opinion (but who cares this
is trivial to change). The code imports
300 randomly selected words from the dictionary, which are organized based on the string length 
allowing for a method to choose between easy, medium, and hard words (typically
smaller words are harder to find). The lattice is generated using SFML
vertex arrays, and the word placement algorithm is designed as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Start with the strings with the largest length as the geometric constraints are stricter.&lt;/li&gt;
&lt;li&gt;Randomly select a starting position in the grid and generate a list of possible directions
based on geometric considerations; there are 8 possibilities (vertical, horizontal,
and the diagonals). Randomly select a possible direction, and place the first word.&lt;/li&gt;
&lt;li&gt;Continue the procedure for all words to find, typically 15 words (5 from each hardness category).&lt;/li&gt;
&lt;li&gt;When a new word is randomly positioned, an overlap check is performed. If an overlap exists,
check to see if the character is the same. If it is then keep it, otherwise discard the word
and move on to another. There are many smarter approaches, I imagine, but this is what I how
I positioned many words in a grid.&lt;/li&gt;
&lt;li&gt;Fill the in the empty spaces with randomly generated letters.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The game may be seen &lt;a href=&quot;https://youtu.be/YexCgQyk7TE&quot;&gt;here&lt;/a&gt;. A cheat button is achieved
by simply toggling between two sprites (a checked/unchecked box). Mouse events are handled
using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sf::Mouse::isButtonPressed(sf::Mouse::Left)
sf::Event::MouseButtonPressed	
sf::Event::MouseMoved
sf::Event::MouseButtonReleased
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;logic methods. For example, when the mouse button is clicked &lt;i&gt;once&lt;/i&gt; the cell must turn red;
when the mouse moves, the cells turn red in vertical/horizontal/diagonal preferences
which is achieved using simple vectors and angular cuts. When the mouse button is released,
a method must be invoked to check if the highlighted region is in fact a word on the list. If
it is, turn the blocks green, otherwise reset the blocks and cue the audio for failure.
The words to find list has been sorted by string length, and a strike-out effect is achieved
by using vertex arrays. The audio clips are handled by SFML’s audio module which is
simple to use for this task.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/images/word_search/word_search_thumbnail.png&quot; alt=&quot;&quot; width=&quot;99%&quot; height=&quot;99%&quot; /&gt;
&lt;/figure&gt;</content><summary type="html">An interactive word search generator/game</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="" /></entry><entry><title type="html">Mona Lisa from Triangles?</title><link href="/blog/mona-lisa/" rel="alternate" type="text/html" title="Mona Lisa from Triangles?" /><published>2017-08-28T00:00:00-04:00</published><updated>2017-08-28T00:00:00-04:00</updated><id>/blog/mona-lisa</id><content type="html" xml:base="/blog/mona-lisa/">&lt;p&gt;&lt;i&gt;Disclaimer&lt;/i&gt;: I got the idea from &lt;a href=&quot;https://rogerjohansson.blog/2008/12/07/genetic-programming-evolution-of-mona-lisa/&quot;&gt;this blogging site&lt;/a&gt;,
but the implementation/algorithms are mine. The blogger calls this a &quot;genetic algorithm&quot; but it's just a simple hill-climbing
method defined by some &amp;chi;&lt;sup&gt;2&lt;/sup&gt;, a common technique in my work.
Additionally, I used the bare-bones &lt;a href=&quot;https://www.sfml-dev.org/&quot;&gt;SFML library&lt;/a&gt; which required
significant image processing and filtering methods to be developed; this has been done on purpose for my own education!
While the results are pleasing, the algorithm is not practical (at least mine). An animation of the algorithm is located at the bottom.
&lt;/p&gt;

&lt;h2 id=&quot;concept&quot;&gt;Concept&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;image right&quot;&gt;&lt;img src=&quot;/images/mona_lisa/original.jpg&quot; alt=&quot;&quot; /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The goal is to mimic or replicate an input image using polygons, or triangles in this case.
The main components of the algorithm are as follows:
&lt;ol&gt;
&lt;li&gt;Have an input image that we wish to copy, &lt;i&gt;e.g.&lt;/i&gt; the Mona Lisa&lt;/li&gt;
&lt;li&gt;Randomly generate an initial set of &lt;i&gt;N&lt;/i&gt; triangles, typically 50-500&lt;/li&gt;
&lt;li&gt;Define an appropriate &amp;chi;&lt;sup&gt;2&lt;/sup&gt; function, often referred to as a loss or fitness function, which
    will allow us to quantify the difference between the triangle image and the input image &lt;/li&gt; 
&lt;li&gt;Apply a &lt;q&gt;mutation&lt;/q&gt;, &lt;i&gt;i.e.&lt;/i&gt; randomly tweak a characteristic of the triangle like a vertex
    coordinate or an RGBA value&lt;/li&gt;
&lt;li&gt;Calculate the &amp;chi;&lt;sup&gt;2&lt;/sup&gt; between the mutated image and the input; if the function determines
    that the mutation is more similar to the input then accept the change. Otherwise, discard it, and apply another mutation&lt;/li&gt;
&lt;li&gt;Repeat until the loss function does not change significantly.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With low-level C++ libraries, the difficulty here is to develop the appropriate routines to handle the image processing.
For example, &lt;i&gt;N&lt;/i&gt; triangles are randomly generated in which there is significant overlap; therefore, RGBA values
are being added together in a complicated manner. While more sophisticated methods can be developed,
I chose to draw the triangles on a canvas in order to visually see
the result of a mutation (for example, a coordinate mutation can affect a significant fraction of the RGBA of the mutation image).
In order to process the mutated image, the code takes a screen shot of the mutation and then breaks it apart into
a vector such that the RGBA components may be easily compared to the input image.&lt;/p&gt;

&lt;p&gt;Let's define the word &lt;i&gt;mutation&lt;/i&gt; clearly. A mutation only applies to the triangle image, and in general
represents some random tweaking of triangle attributes. In this case, one triangle has three vertices and each
vertex has two coordinates and an RGBA value; this is 6 parameters per vertex for a grand total of 18 per triangle! Therefore,
the number of parameters to tweak making up the triangle image goes like &lt;i&gt;N*18&lt;/i&gt; where &lt;i&gt;N&lt;/i&gt; is the number
of triangles. The difficulty is to decide how much to randomly tweak a parameter. If the mutation is too small then
it is easy for the code to get stuck in a local minima, but if it is too large then the mutation rate is compromised.
I used a flat random number generator for all parameters, and kept the coordinate mutations loose while keeping tight
mutations on the color components. There is a lot of room for improvement in these choices, I think.&lt;/p&gt;

The &amp;chi;&lt;sup&gt;2&lt;/sup&gt; function is defined to be the square difference of R,G,B,A components for all pixels between the input
and mutated image, and is normalized by &lt;i&gt;(N pixels)*4*256*256&lt;/i&gt; such that
the loss function &lt;i&gt;L = 1-&lt;/i&gt;&amp;chi;&lt;sup&gt;2&lt;/sup&gt; yields a number less than or equal to 1 where 1 is a perfect match.
This can be computationally slow if you have large images as the code is simply brute force. The heart of the
algorithm depends on this function as the newly mutated image gets compared to the input image via the loss function. If
the loss function is calculated to be better than the previous triangle image, then the mutation is kept; otherwise,
the code will discard the mutation and randomly try again.
The mutation rate, &lt;i&gt;i.e.&lt;/i&gt; the number of accepted mutations over the total number of mutation attempts,
at first is acceptable but then quickly becomes linear resulting in a slow algorithm (still fun though).&lt;/p&gt;

&lt;figure&gt;
  &lt;img src=&quot;/images/mona_lisa/mutation_rate.png&quot; alt=&quot;&quot; height=&quot;99%&quot; width=&quot;99%&quot; /&gt;
  &lt;figcaption&gt;Fig. 1 - The normalized loss (L=1-&amp;chi;&lt;sup&gt;2&lt;/sup&gt;) as a function of mutation number.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt; &lt;/p&gt;

&lt;h2 id=&quot;results&quot;&gt;Results&lt;/h2&gt;
&lt;p&gt;In order to make convergence faster, I gridded up the input image and found the average color of each grid.
I generated 300 triangles with randomly placed vertices and calculated the vertex coordinate average which dictates
the triangle's initial color based off the average grid colors.
I let the code do 1e6 mutation attempts (as opposed to successes)
in which only 23,721 mutations were accepted, which is a mutation rate of 2.4% if I assume linearity.
The best loss is L=0.9966, and it remained this way for quite some time as the slope is so small (see Fig. 1 at large mutations).
The quality of the image does converge, meaning that more computational time is most likely futile. The results
of this project may be seen by the animation in Fig. 2.
The results may be greatly improved by considering polygons (I've seen ellipses too), but the number of parameters
to tweak is now &lt;i&gt;N*V*6&lt;/i&gt; where &lt;i&gt;V&lt;/i&gt; is the number of vertices..
Also, the use of triangles leads to sharp edges in the output image. This can be smoothed out by developing
filtering techniques, &lt;i&gt;e.g.&lt;/i&gt; a Gaussian blur, and I spent a great deal of time learning how to apply
convolution matrices or image masks (google kernel image processing). 
&lt;/p&gt;

&lt;figure&gt;
  &lt;img src=&quot;/images/mona_lisa/mona_lisa_rs.gif&quot; alt=&quot;&quot; height=&quot;30%&quot; width=&quot;30%&quot; /&gt;
  &lt;figcaption&gt;Fig. 2 - An animation of mutation attempts and successes. The page might need to be reloaded
  as I currently do not know how to control/pause the .gif.&lt;/figcaption&gt;
&lt;/figure&gt;</content><summary type="html">A hill climbing method to mimic an input image with randomly generated triangles</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/images/mona_lisa/mona_lisa.jpg" /></entry><entry><title type="html">Double Pendulum</title><link href="/blog/double-pendulum/" rel="alternate" type="text/html" title="Double Pendulum" /><published>2017-07-27T00:00:00-04:00</published><updated>2017-07-27T00:00:00-04:00</updated><id>/blog/double-pendulum</id><content type="html" xml:base="/blog/double-pendulum/">&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;&lt;span class=&quot;image left&quot;&gt;
&lt;img src=&quot;/images/double_pend/double_pend_long.png&quot; alt=&quot;&quot; width=&quot;99%&quot; height=&quot;99%&quot; /&gt;
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;
The double pendulum is a canonical classical mechanics problem to introduce
the concept of chaos; the description will therefore be brief.
First, find the equations of motion (EOM) using forces or
the Lagrangian method; this describes the angles and angular velocities of the two masses.
The derivation will not be done here as it is beyond the scope of this website, but
it is a must-do mechanics problem to solve for undergraduates.
The masses and pendula arm-lengths can be different which gives rise to interesting behavior, and
the initial angles are chosen with a flat random number generator.
The equations of motion need to be approximated, and in this case I used the Runge-Kutta method
otherwise known as RK4. In order to proceed with the simulation, a time variable is
needed to keep track of the evolution of the angles/angular velocities given some random initial
condition. A simple tracer routine has been added to follow the position of the masses,
and the alpha component decays as a function of position within the tracer C++ vector (I limit
the number of traces to roughly 200-300 to avoid messy patterns).
A small video displaying the simulation output may be seen 
&lt;a href=&quot;https://youtu.be/CuhPbDQs3eY&quot;&gt;here&lt;/a&gt;. Note that with very little
effort, the double pendulum simulation may be used as a spirograph generator. In this
case, the RK4 method (and equations of motion) is discarded and one simply chooses angular velocities
and arm-lengths.
&lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;/images/double_pend/double_pend_rainbow.png&quot; alt=&quot;&quot; width=&quot;99%&quot; height=&quot;99%&quot; /&gt;
&lt;figcaption&gt;
Fig. 1 - The double pendulum simulation with rainbow (fading alpha) tracers on the second (first) mass.
&lt;/figcaption&gt;
&lt;/figure&gt;</content><summary type="html">Simulating the double pendulum using RK4</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="" /></entry><entry><title type="html">Koch Snowflake</title><link href="/blog/koch-snowflake/" rel="alternate" type="text/html" title="Koch Snowflake" /><published>2017-05-10T00:00:00-04:00</published><updated>2017-05-10T00:00:00-04:00</updated><id>/blog/koch-snowflake</id><content type="html" xml:base="/blog/koch-snowflake/">&lt;figure&gt;
&lt;img src=&quot;/images/koch_snowflake/flake_thumbnail.png&quot; alt=&quot;&quot; title=&quot;Koch&quot; width=&quot;99%&quot; height=&quot;99%&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;span class=&quot;image left&quot;&gt;&lt;img src=&quot;/images/koch_snowflake/idea.png&quot; alt=&quot;&quot; /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;
I worked on this project immediately after the tree fractal. Admittedly, the geometry is more
difficult but the fractal generation concept is the same; find a base operation, and apply
it iteratively. The fractal begins by defining an
equilateral triangle, and let's refer to this as iteration 0. Iteration 1 is
formed by taking each line segment making up the base triangle, splitting it into thirds,
removing the center segment, and then building a smaller equilateral (with one side missing)
with two additional line segments. The result is a star.
Therefore, the base operation of the fractal consists of accepting one line segment
and returning four in the proper orientation. Repeat the iteration process until satisfied, but
practically only the first 6 iterations or so make noticeable changes without magnification.
An animation of my Koch snowflake may be seen by Fig. 2. The area of the fractal
quickly converges, but the perimeter tends towards infinity; see Fig. 3 for my results.
Note that the number of line segments to consider grows rapidly: &lt;i&gt;3*4&lt;sup&gt;n&lt;/sup&gt;&lt;/i&gt;
where &lt;i&gt;n&lt;/i&gt; is the iteration number. Therefore, the animation displays the first
10 iterations resulting in a fractal with &lt;i&gt;3.14*10&lt;sup&gt;6&lt;/sup&gt;&lt;/i&gt; line segments.
&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;/images/koch_snowflake/asymm.gif&quot; alt=&quot;&quot; title=&quot;Koch snowflake animation&quot; width=&quot;80%&quot; height=&quot;80%&quot; /&gt;
&lt;figcaption&gt;Fig. 2 - The first 10 iterations of a variation of the Koch snowflake. While
the area of the fractal converges rapidly, the perimeter tends towards infinity, see
Fig. 3.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;/images/koch_snowflake/results.png&quot; alt=&quot;&quot; title=&quot;Koch snowflake animation&quot; width=&quot;99%&quot; height=&quot;99%&quot; /&gt;
&lt;figcaption&gt;Fig. 3 - The area and perimeter of a true Koch snowflake (not the the one seen in the
animation). The area converges quickly while the perimeter diverges towards infinity.
The convergence of the fractal area is suppose to be 8/5 times the original
area of the base triangle, which is observed in the plot.&lt;/figcaption&gt;
&lt;/figure&gt;</content><summary type="html">A variation of the Koch snowflake</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="" /></entry><entry><title type="html">Square Art</title><link href="/blog/square-art/" rel="alternate" type="text/html" title="Square Art" /><published>2017-02-05T00:00:00-05:00</published><updated>2017-02-05T00:00:00-05:00</updated><id>/blog/square-art</id><content type="html" xml:base="/blog/square-art/">&lt;p&gt;Working on it..&lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;/images/square_art/thumbnail_small.png&quot; alt=&quot;&quot; /&gt;
&lt;figcaption&gt;
Fig. 1 - 
&lt;/figcaption&gt;
&lt;/figure&gt;</content><summary type="html">Creating interesting pattens with squares</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="" /></entry><entry><title type="html">Snake</title><link href="/blog/slither/" rel="alternate" type="text/html" title="Snake" /><published>2016-07-18T00:00:00-04:00</published><updated>2016-07-18T00:00:00-04:00</updated><id>/blog/slither</id><content type="html" xml:base="/blog/slither/">&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;
&lt;p&gt;There are times when a student begins a coding project and the end-goal turns out to be
absolutely worthless, and admittedly this is one of posts.
I wanted to replicate a complete game from scratch (menus, high scores, user-interactions,
and a purpose), but a Snake game is not that much fun to play anymore! However,
the Snake project, which was inspired by &lt;a href=&quot;http://slither.io/&quot;&gt;slither.io&lt;a&gt;&lt;/a&gt; combined
with the game from the late 70s, was fun to make and a great learning experience.
The game is simple: eat food and grow, but do not run in to the wall or cross over yourself.
The program was coded from scratch with C++
and the SFML libraries for drawing primitive shapes and basic event-handling (e.g. hitting
a letter on the keyboard), and includes the following:&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;a menu framework including high scores and a screen for the player to type the name&lt;/li&gt;
&lt;li&gt;a snake made out of overlapping circles in an alternating rainbow pattern&lt;/li&gt;
&lt;li&gt;randomly placed food of varying sizes (larger sizes increase the score/snake more) and the
    food moves in a circular path of some random radius to make it more difficult&lt;/li&gt;
&lt;li&gt;a point system based on food consumption&lt;/li&gt;
&lt;li&gt;the snake is controlled by the arrows, and may be accelerated to larger speeds with the space-bar&lt;/li&gt;
&lt;li&gt;when the snake hits the wall or itself (which requires simple collision detection),
   a death method is invoked which includes increasing the radii of the circles making up the snake.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The game is silly, obviously, and I probably could not even get my 5 year old nephew to play this
even if I paid him… BUT this was the first game and it was important to finish what I started.
Making the game more advanced, e.g. adding
other competing snakes with some automation, is now simply a matter of investing more time.
See the figure for some screen shots of the menus, game, and death.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;
&lt;figure&gt;
  &lt;img src=&quot;/images/slither/game_small.png&quot; alt=&quot;&quot; height=&quot;99%&quot; width=&quot;99%&quot; /&gt;
&lt;/figure&gt;</content><summary type="html">An interactive snake game</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="" /></entry><entry><title type="html">Tree Fractal</title><link href="/blog/tree-fractal/" rel="alternate" type="text/html" title="Tree Fractal" /><published>2016-05-08T00:00:00-04:00</published><updated>2016-05-08T00:00:00-04:00</updated><id>/blog/tree-fractal</id><content type="html" xml:base="/blog/tree-fractal/">&lt;figure&gt;
  &lt;img src=&quot;/images/tree_fractal/fractal_tree_multi.jpg&quot; alt=&quot;&quot; height=&quot;99%&quot; width=&quot;99%&quot; /&gt;
  &lt;figcaption&gt;Fig. 1 - The fractal tree generated with branch angles of 23 (left panel)
  and 60 (right) degrees.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;generating-and-animating-the-fractal&quot;&gt;Generating and Animating the Fractal&lt;/h2&gt;
&lt;p&gt;There are many ways to generate a simple tree fractal. A quick google search gives many variations
and patterns, symmetric and asymmetric, as even small changes to the initial length and/or
angle gives interesting results. I will only describe &lt;i&gt;my&lt;/i&gt; fractal as I am not a
fractal expert; the goal for me was to generate a symmetric tree fractal,
and then to tweak parameters (such as angle) and make an animation.&lt;/p&gt;

&lt;p&gt;The fractal starts with a tree trunk of length &lt;i&gt;l&lt;/i&gt;, and think of
the top of the trunk as a node where we will connect branches. Fractals
are iterative objects, so in this case the trunk is referred to as level zero.
Each time we increment the level, 2 branches will be connected to each node
of the previous level resulting in 2&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; new branches where &lt;i&gt;n&lt;/i&gt;
represents the level. A branch is just a line defined by two coordinates.
The first level of the fractal, then, generates two branches,
both assigned a length &lt;i&gt;al&lt;/i&gt; where &lt;i&gt;a&lt;/i&gt; is some fraction to be defined by the coder,
with the trunk node as the starting coordinate; the end coordinate depends on the fractal generation
angle. If I choose an angle of say 23 degrees as in Fig. 1, then the first level
branches have end points that are plus/minus 23 degrees with respect to the vertical, or
more generally the directional vector of the trunk (or branch of the previous level).
Level two branches (there are 2&lt;sup&gt;2&lt;/sup&gt;=4)
use level 1 nodes as input where the length is now &lt;i&gt;a&lt;sup&gt;2&lt;/sup&gt;l&lt;/i&gt;, and the end points
are defined &lt;i&gt;relative&lt;/i&gt; to the level 1 branch directional vectors. The process
is iterated to as many levels as one wants, but note that the length of level &lt;i&gt;n&lt;/i&gt;
branches are reduced relative to the trunk by a factor of &lt;i&gt;a&lt;sup&gt;n&lt;/sup&gt;&lt;/i&gt;. For example,
if we choose &lt;i&gt;a&lt;/i&gt;=0.7, then the length of level 7 branches is 0.7&lt;sup&gt;7&lt;/sup&gt;=0.08
or 8% of the trunk's length which quickly becomes difficult to visualize.
Additionally, the tree fractal naturally gives rise to a curling
or rotational effect which yields often unexpected behavior, &lt;i&gt;e.g.&lt;/i&gt; the
right panel of Fig. 1.&lt;/p&gt;

&lt;p&gt;
I used a value of &lt;i&gt;a&lt;/i&gt;=0.65 and &lt;i&gt;n&lt;/i&gt;=15, and incrementally changed the color of branches
as the algorithm progresses to higher branch levels, hence the variations of green
and the red/pink buds. Obviously a great deal of time could be invested tweaking
various parameters and checking the result; the tweaking can be intensified by
considering asymmetric parameters for left/right branch generation at any particular node.
The algorithm can easily be extended to scan over a range of branch generation angles,
say 0 to 360 degrees, and the output can be strung together to create a .gif using
conventional linux facilities. The results of such a procedure may be seen by Fig. 2,
and if the .gif does not work then see the video on my
&lt;a href=&quot;https://youtu.be/7bijV3FGrBk&quot;&gt;youtube channel&lt;/a&gt;.
Fractal analysis can be performed on the output, but I stopped here. See
&lt;a href=&quot;https://www.youtube.com/watch?v=Ec8Q1q9cbbo&quot;&gt;this video&lt;/a&gt; for
a spectacular demonstration of the variety of tree fractals.
&lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;/images/tree_fractal/fractal2.gif&quot; alt=&quot;&quot; title=&quot;Tree fractal animation&quot; width=&quot;99%&quot; /&gt;
&lt;figcaption&gt;Fig. 2 - Scanning over branch generation angles of 0 to 360 degrees in 1 degree
increments, and stitching all the images together to create an animation.&lt;/figcaption&gt;
&lt;/figure&gt;</content><summary type="html">Generation and visualization of a Pythagoras tree</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="" /></entry></feed>
