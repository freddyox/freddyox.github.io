---
layout: post
title:  "Mona Lisa from Triangles?"
date:   2017-08-28
excerpt: "A hill climbing method to mimick an input image with randomly generated triangles."
image: "/images/mona_lisa/mona_lisa.jpg"
cimage: "/images/mona_lisa/mona_lisa.jpg"
---

<p><i>Disclaimer</i>: I got the idea from <a href="https://rogerjohansson.blog/2008/12/07/genetic-programming-evolution-of-mona-lisa/">this blogging site</a>,
but the implementation/algorithms are mine. The blogger calls this a "genetic algorithm" but it's just a simple hill climbing
method defined by some &chi;<sup>2</sup>, a common technique in my work.
Additionally, I used the bare-bones <a href="https://www.sfml-dev.org/">SFML library</a> which required
significant image processing and filtering methods to be developed; this has been done on purpose for my own education!
While the results are pleasing, the algorithm is not practical (at least mine),
</p>

## Concept
<span class="image right"><img src="{{ "/images/mona_lisa/original.jpg" | absolute_url }}" alt="" /></span>
<p>The goal is to mimick or replicate an input image using polygons, or triangles in this case.
The main components of the algorithm are as follows:
<ol>
<li>Have an input image that we wish to copy, <i>e.g.</i> the Mona Lisa</li>
<li>Generate an initial set of <i>N</i> triangles randomly, typically 50-500</li>
<li>Define an appropriate &chi;<sup>2</sup> function, often referred to as a loss or fitness function, which
    will allow us to quantify the difference between the triangle image and the input image </li> 
<li>Apply a <q>mutation</q>, <i>i.e.</i> randomly tweak a characteristic of the triangle like a vertex
    coordinate or an rgba value</li>
<li>Calculate the &chi;<sup>2</sup> between the mutated image and the input; if the function determines
    that the mutatation is more similar to the input then accept the change. Otherwise, discard it, and apply another mutation.</li>
<li>Repeat until the loss function does not change significantly.</li>
</ol>

The &chi;<sup>2</sup> function is defined to be the square difference of r,g,b,a components for all pixels between the input
and mutated image, and is normalized by <i>(N pixels)*4*256*256</i> such that
the loss function <i>L = 1-</i>&chi;<sup>2</sup> yields a number less than or equal to 1 where 1 is a perfect match.
This can be computationally slow if you have large images as the code is simply brute force.
The input image is put into a look-up table in order to handle the color components of
all pixels.  
The mutation rate, <i>i.e.</i> the number of accepted mutations over the total number of mutation attempts,
at first is acceptable but then quickly becomes linear resulting in a slow algorithm (still fun though).</p>

 <figure>
  <img src="/images/mona_lisa/mutation_rate.png" alt="" height="99%" width="99%">
  <figcaption>Fig. 1 - The fitness (normalized 1-&chi;<sup>2</sup>) as a function of mutation number.</figcaption>
</figure>
<p> </p>

<p>In order to make convergence faster, I gridded up the input image and found the average color of each grid.
I generated 300 triangles with randomly placed vertices, and calculated the vertex coordinate average which dictates
the initial color that is assigned to the triangle. I let the code do 1e6 mutation attempts (as opposed to successes)
in which only 23,721 mutations were accepted, which is a mutation rate of 2.4% if I assume linearity.
The best normalized 1-&chi;<sup>2</sup>=0.9966, and it remained this way for quite some time as the slope is so small.
The quality of the image does converge, meaning that more computational time is most likely futile. </p>

 <figure>
  <img src="/images/mona_lisa/mona_lisa_rs.gif" alt="" height="30%" width="30%">
  <figcaption>Fig. 2 - An animation of mutations attempts and successes.</figcaption>
</figure>
	