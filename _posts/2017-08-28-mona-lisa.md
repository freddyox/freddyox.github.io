---
layout: post
title:  "Mona Lisa from Triangles?"
date:   2017-08-28
excerpt: "A hill climbing method to mimick an input image with randomly generated triangles."
image: "/images/mona_lisa/mona_lisa.jpg"
cimage: "/images/mona_lisa/mona_lisa.jpg"
---

<p><i>Disclaimer</i>: I got the idea from <a href="https://rogerjohansson.blog/2008/12/07/genetic-programming-evolution-of-mona-lisa/">this blogging site</a>,
but the implementation/algorithms are mine. The blogger calls this a "genetic algorithm" but it's just a simple hill climbing
method defined by some &chi;<sup>2</sup>, a common technique in my work.
Additionally, I used the bare-bones <a href="https://www.sfml-dev.org/">SFML library</a> which required
significant image processing and filtering methods to be developed; this has been done on purpose for my own education!
While the results are pleasing, the algorithm is not practical (at least mine),
</p>

## Concept
<span class="image left"><img src="{{ "/images/mona_lisa/original.jpg" | absolute_url }}" alt="" /></span>
<p>The goal is to mimick or replicate an input image using <i>N</i> randomly generated polygons.

The guy calls it a genetic algorithm, but I do not see how. The idea is somewhat simple, and note
that we will be at the pixel level. Each pixel has a coordinate and color, and each color has an rgba component where a is the transparency.

Here are the main components of the algorithm:
1) Have an input image like the Mona Lisa
2) Draw N triangles randomly, typically it is 50-500, and "mutate" it. In other words, randomly adjust the triangle vertex positions or the triangle's color components (r,g,b,a). There are some difficulties that arise here....there are a lot of choices...and how much should I wiggle each thing? I realized it is very easy to get stuck in local minima, so the random numbers need to have some freedom which definitely changes the rate of convergence.
3) Compare the triangle image to the input image with a chi^2 function (defined below).
4) If the chi^2 function determines that the mutated image is more similar to the input image than the previous, keep the mutation. Otherwise discard it.
5) Continue....

The chi^2 function is the square difference of r,g,b,a components for all pixels between the input and mutated image. It can be normalized by the (number of pixels*4*256*256), therefore 1-\chi^2 yields a number less than or equal to 1 where 1 is a perfect match. This can be computationally slow if you have large images and the code is simply brute force. Even though a pixel array is technically row by column, a double for-loop is NOT necessary. Also, the input image can be put into some map or hash table (lookup table). The rate of convergence **at first** is acceptable but then it quickly becomes linear in which the slope is damn slow, see image.


So, I gridded up the input image, and found the average color of each grid. Then I generated 300 triangles with randomly placed vertices, and the initial color is determined by the grid location of the vertex coordinate average. I let the code do 1e6 mutation attempts (as opposed to successes) in which only 23,721 mutations were accepted => mutation rate of 2.4% if I assume linearity. The best (1-\chi^2)=0.9966, and it remained this way for quite some time as the slope is so small. The quality of the image does converge, so it is not like I can let my computer run for 10+ hours and have a perfect copy.

The result is the 2nd row of comparison.pdf. It became clear by examining my outputs that the ONLY way to make them look better is to process the images. I then spent a great deal of time learning how to apply filters, i.e. gaussian blurs, edge detection, etc. The bottom row is a gaussian blurred result (the blurring is very very minimal), and made smaller to make the imperfections less apparent. The filters are so useful and trivial to learn: https://en.wikipedia.org/wiki/Kernel_(image_processing) or even better http://lodev.org/cgtutor/filtering.html
Basically you have a matrix is applied to each pixel ( think of a 3x3 matrix and the center of the matrix is the pixel ). The neighbor pixels get multiplied by the matrix on an element by element basis, and the results are stunning. See the edge detection which is simply a different matrix, or the emboss which looks sick.

The animated result of my simulation with a gaussian blur applied may be seen by mona_lisa_rs.gif. The reason you see random triangles popping up in the end is b/c I have to draw the mutated image so that I can take a screenshot (in code of course), then do my analysis. I would have to code another window that only plots the best image for it to be even smoother, but its irrelevant now.

I think the guy with the original idea has more sophisticated image processing techniques because you can barley see triangle boundaries. He claims to have 50 triangles and I find this hard to believe. 
</p>